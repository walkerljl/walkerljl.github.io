---
layout : post
title : Elasticsearch数据
date : 2016-08-01
author : walkerljl
categories : blog
tag : Elasticsearch
---

# 一.文档
在很多程序中，大部分实体或者对象都被序列化为包含键和值的JSON对象。键是一个字段或者属性的名字，值可以是一个字符串、数字、布尔值、对象、数组或者是其他的特殊类型，比如代表日期的字符串或者代表地理位置的对象。

通常情况下，我们使用可以互换对象和文档。然而，还是有一个区别的。对象（object）仅仅是一个json对象，类似于hash、hash映射、字段或关联数组。对象（Objects）则可以包含其它对象（Objects）。

在Elasticsearch中，文档这个单词有特殊的含义。它指的是在Elasticsearch中被存储到唯一ID下的由最高级或者根对象（root object）序列化而来的JSON。

# 二.文档元数据
一个文档不只包含了数据。它还包含元数据（metadata）--关于文档的信息。有三个元数据是必须存在的：

|名字|说明|
|---|:--:|
|_index|文档存储的地方|
|_type|文档代表的对象种类|
|_id|文档的唯一编号|

1. _index

索引类似于传统数据库中的“数据库”--也就是我们存储并且索引相关数据的地方。

>在Elasticsearch中，我们的数据都在分片中被存储以及索引，索引只是一个逻辑命名空间，它可以将一个或多个分片组合在一起。然而，这只是一个内部的运作原理--我们的程序可以根本不关心分片。对于我们的程序来说，我们的文档存储在索引中。

索引的名称全部小写，也不能以下划线开头，不能包含逗号。

2. _type
在程序中，我们使用对象代表“物品”，比如一个用户、一篇博文、一条留言或者一个邮件。每一个对象都属于一种类型，类型定义了对象的属性或者与数据的关联。用户类的对象可能就会包含名字、性别、年龄以及邮箱地址等。
在传统的数据库中，我们总是将同类的数据存储在同一个表中，因为它们的数据格式是相同的。同理，在Elasticsearch中，我们使用同样类型的文档来代表同类“事物”，也是因为它们的数据结构结构是相同的。

每一个类型都拥有自己的映射（mapping）或者结构定义，它们定义了当前类型下的数据结构，类似于数据库表中的列。所有类型下的文档会被存储在同一个索引下，但是映射会告诉你会告诉你Elasticsearch不同的数据应该如何被索引。

3. _id 
id是一个字符串，当它与_index以及_type组合时，就可以来代表Elasticsearch中一个特定的文档。我们创建了一个新的文档时，你可以自己提供一个_id或者可以让Elasticsearch帮你生成一个。

4. 其它的元数据

# 三.索引
文档通过索引API被索引（存储并使其可搜索）。但是最开始我们需要决定我们将文档存储在哪里。正如之前提到的，一篇文档通过_index、_type以及_id来确定它的唯一性。我们可以自己提供一个_id，或者也使用index API帮我们生成一个。

1. 使用自己的ID
如果你的文档拥有天然的标识符（例如user_account字段或者文档中其它的标识值），这时你就可以提供你自己的_id：

```
PUT /{index}/{type}/{id}
{
	"field" : "value",
	...
}
```
在Elasticsearch中，每一个文档都有一个文档号码。每当文档产生变化时（包括删除），_version就会增大。后面会详细讲解如何使用_version的数字来确认你的程序不会随意替换掉不想覆盖的数据。

2. 自增ID
如果我们的数据中没有比较好的标识符，可以让Elasticsearch为我们自动生成一个。请求的结构发生了变化。
```
POST ／{index}/{type}/ 
{
	"field" : "value",
	...
}
```
自生成的ID是由22个字母组成的。

# 四.检索文档
1. 普通检索

```
GET /{index}/{type}/{id}?pretty
```

2. 检索文档的一部分

```
GET /{index}/{type}/{id}?_source=field1,field2,...
```

3. 只检索_source字段而不要其它元数据

```
GET /{index}/{type}/{id}?_source
```

# 五.检索文档是否存在

```
	HEAD /{index}/{type}/{id}
```
>如果文档存在，返回状态码200；否则返回400。

# 六.更新文档
文档是不可改变的。如果需要改变以及存在的文档，我们可以用索引API来重新索引或者替换掉它。

```
PUT /{index}/{type}/{id}
{
	"field" : "value",
	...
}
```
>在返回的数据中，created被标记为false是因为在同索引、同类型下已经存在同ID的文档。
>在内部，Elasticsearc已经将旧文档标记为删除并且添加了新的文档。旧的文档并不会立即消失，但是你也无法访问它。Elasticsearch会在你继续添加更多数据的时候在后台清理已经删除的文件。

我们也可以修改部分字段，原理和下方式的万全一样：
1. 从旧的文档中检索JSON。
2. 修改它。
3. 删除修的文档。
4. 索引一个新的文档。
唯一不同的是，使用了update API你就不需要使用get然后再操作index请求了。

# 七.创建
当我们索引一个文档时，如何确定我们是创建了一个新的文档还是覆盖了一个已经存在的文档？
请牢记_index，_type，_id组成了唯一的文档标记，所以为了确定我们创建的是全新的内容，最简单的方法就是使用POST方法，让Elasticsearch自动创建不同的_id：

```
POST /{index}/{type}{...}
```
然而，我们可能已经决定好了_id，所以需要告诉Elasticsearch只有当_index、_type、_id这3个属性全部相同的的文档不存在时才接受我们的请求。实现这个目的有两种方法，它们实质上是一样的：

```
PUT /{index}/{type}/{id}?op_type=create

PUT /{index}/{type}/{id}/_create
```

创建了新文档返回201，已经存在返回408。

# 八.删除

```
DELETE /{index}/{type}/{id}
```
成功返回200，文档不存在反问404，但是返回内容的“_version”会增加1。这个是内部管理的一个部分，它保证了我们在多个节点间的不同操作的顺序都被正确标记了。
# 参考资料
1. <https://es.xiaoleilu.com>
2. <http://www.learnes.net>
